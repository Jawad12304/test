<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Happy Birthday Asmara!</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Arial', sans-serif; }
        #ui {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: white;
            pointer-events: none;
            text-shadow: 0 0 10px rgba(255,105,180,0.8);
            z-index: 10;
        }
        h1 { font-size: 3rem; margin: 0; }
        p { font-size: 1.2rem; opacity: 0.8; }
        #video-container {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 180px;
            border: 2px solid #ff69b4;
            border-radius: 10px;
            overflow: hidden;
            transform: scaleX(-1);
            opacity: 0.7;
        }
        canvas { display: block; }
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        #bottom-text {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            color: white;
            font-size: 1.5rem;
            text-shadow: 0 0 10px rgba(255,105,180,0.8);
            animation: blink 4s infinite;
        }
    </style>
</head>
<body>

    <div id="ui">
        <h1>Happy Birthday Asmara! âœ¨</h1>
        <p>Click on the on the Particle to continue!</p>
    </div>

    <div id="video-container">
        <video id="input_video" style="width: 100%; height: auto;"></video>
    </div>

    <audio id="birthdayAudio" src="birthday.mp3" preload="auto"></audio>

    <div id="bottom-text">Click fast with the music</div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        // --- CONFIG ---
        const PARTICLE_COUNT = 8000;
        let currentShape = 0; // 0:Heart, 1:Flower, 2:Saturn, 3:Fireworks, 4:Asmara
        let targetPositions = new Float32Array(PARTICLE_COUNT * 3);
        let colors = new Float32Array(PARTICLE_COUNT * 3);
        let handX = 0, handY = 0, isPinching = false;

        // --- THREE.JS SETUP ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 6;

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        
        for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
            positions[i] = (Math.random() - 0.5) * 15;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const material = new THREE.PointsMaterial({
            size: 0.035,
            vertexColors: true,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        const particleSystem = new THREE.Points(geometry, material);
        scene.add(particleSystem);

        // --- TEXT RASTERIZER (ASMARA) ---
        function getTextPoints(text) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 600;
            canvas.height = 200;
            
            ctx.fillStyle = 'white';
            ctx.font = 'bold 100px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(text, 300, 120);

            const imageData = ctx.getImageData(0, 0, 600, 200).data;
            const points = [];
            for (let y = 0; y < 200; y += 2) {
                for (let x = 0; x < 600; x += 2) {
                    const alpha = imageData[(y * 600 + x) * 4 + 3];
                    if (alpha > 128) {
                        points.push({
                            x: (x - 300) * 0.025,
                            y: (100 - y) * 0.025
                        });
                    }
                }
            }
            return points;
        }

        const namePoints = getTextPoints("ASMARA");

        // --- SHAPE GENERATORS ---
        function updateShape() {
            const colorObj = new THREE.Color();

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                let x, y, z;
                const t = (i / PARTICLE_COUNT) * Math.PI * 2;
                
                // Switch between templates
                if (currentShape === 0) { // HEART
                    const angle = (i / PARTICLE_COUNT) * Math.PI * 2;
                    x = 1.6 * Math.pow(Math.sin(angle), 3);
                    y = 1.3 * Math.cos(angle) - 0.5 * Math.cos(2 * angle) - 0.2 * Math.cos(3 * angle) - 0.1 * Math.cos(4 * angle);
                    z = (Math.random() - 0.5) * 0.5;
                    colorObj.setHSL(0.95, 0.8, 0.6);
                } 
                else if (currentShape === 1) { // FLOWER
                    const p = 6; 
                    const r = 2.5 * Math.cos(p * t);
                    x = r * Math.cos(t);
                    y = r * Math.sin(t);
                    z = (Math.random() - 0.5) * 0.3;
                    colorObj.setHSL(0.1, 0.9, 0.6);
                }
                else if (currentShape === 2) { // SATURN
                    if (i < PARTICLE_COUNT * 0.5) {
                        const phi = Math.acos(-1 + (2 * i) / (PARTICLE_COUNT * 0.5));
                        const theta = Math.sqrt(PARTICLE_COUNT * 0.5 * Math.PI) * phi;
                        x = 1.5 * Math.cos(theta) * Math.sin(phi);
                        y = 1.5 * Math.sin(theta) * Math.sin(phi);
                        z = 1.5 * Math.cos(phi);
                        colorObj.setHSL(0.6, 0.6, 0.6);
                    } else {
                        const ringA = Math.random() * Math.PI * 2;
                        const d = 2.2 + Math.random() * 0.8;
                        x = Math.cos(ringA) * d;
                        y = Math.sin(ringA) * d * 0.2;
                        z = Math.sin(ringA) * d;
                        colorObj.setHSL(0.05, 0.7, 0.7);
                    }
                }
                else if (currentShape === 3) { // FIREWORKS
                    const phi = Math.random() * Math.PI * 2;
                    const theta = Math.random() * Math.PI;
                    const r = 2.5 + Math.random() * 0.5;
                    x = r * Math.sin(theta) * Math.cos(phi);
                    y = r * Math.sin(theta) * Math.sin(phi);
                    z = r * Math.cos(theta);
                    colorObj.setHSL(Math.random(), 0.8, 0.6);
                }
                else { // ASMARA NAME
                    const pt = namePoints[i % namePoints.length];
                    x = pt.x;
                    y = pt.y;
                    z = (Math.random() - 0.5) * 0.1;
                    colorObj.setHSL(0.8, 1, 0.7); // Bright Pink/Purple
                }

                targetPositions[i * 3] = x;
                targetPositions[i * 3 + 1] = y;
                targetPositions[i * 3 + 2] = z;
                
                colors[i * 3] = colorObj.r;
                colors[i * 3 + 1] = colorObj.g;
                colors[i * 3 + 2] = colorObj.b;
            }
            geometry.attributes.color.needsUpdate = true;
        }

        updateShape();

        // --- GESTURE CONTROL ---
        const videoElement = document.getElementById('input_video');
        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });

        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5 });
        hands.onResults((results) => {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                handX = (0.5 - landmarks[8].x) * 12;
                handY = (0.5 - landmarks[8].y) * 12;

                const dist = Math.hypot(landmarks[4].x - landmarks[8].x, landmarks[4].y - landmarks[8].y);
                
                // Logic change: If pinching, force the shape to be the Name (Asmara)
                if (dist < 0.05) {
                    if (!isPinching) {
                        isPinching = true;
                        currentShape = 4; // Switch to name
                        updateShape();
                    }
                } else {
                    if (isPinching) {
                        isPinching = false;
                        currentShape = (currentShape + 1) % 4; // Back to patterns
                        updateShape();
                    }
                }
            }
        });

        const cameraFeed = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 640, height: 480
        });
        cameraFeed.start();

        // --- ANIMATION ---
        function animate() {
            requestAnimationFrame(animate);

            const posAttr = geometry.attributes.position;
            const lerpSpeed = isPinching ? 0.15 : 0.05;

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const ix = i * 3, iy = i * 3 + 1, iz = i * 3 + 2;

                // Move towards targets + hand offset
                let tx = targetPositions[ix] + handX;
                let ty = targetPositions[iy] + handY;
                let tz = targetPositions[iz];

                posAttr.array[ix] += (tx - posAttr.array[ix]) * lerpSpeed;
                posAttr.array[iy] += (ty - posAttr.array[iy]) * lerpSpeed;
                posAttr.array[iz] += (tz - posAttr.array[iz]) * lerpSpeed;
            }

            posAttr.needsUpdate = true;
            if(!isPinching) particleSystem.rotation.y += 0.01;
            else particleSystem.rotation.y *= 0.9; // Slow down rotation when showing name

            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Click also cycles shapes
        window.addEventListener('mousedown', () => {
            currentShape = (currentShape + 1) % 5;
            updateShape();
            const audio = document.getElementById('birthdayAudio');
            audio.volume = 1;
            audio.play();
        });
    </script>
</body>
</html>